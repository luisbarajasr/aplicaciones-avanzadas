/* ----------------- Lexico - Palabras reservadas ----------------- */
program : 'p' 'r' 'o' 'g' 'r' 'a' 'm';
main : 'm' 'a' 'i' 'n';
var: 'v' 'a' 'r';
end: 'e' 'n' 'd';
int_rw: 'i' 'n' 't';
float_rw: 'f' 'l' 'o' 'a' 't';
void: 'v' 'o' 'i' 'd';
while: 'w' 'h' 'i' 'l' 'e';
do: 'd' 'o';
print: 'p' 'r' 'i' 'n' 't';
if: 'i' 'f';
else: 'e' 'l' 's' 'e';

/* ----------------- Lexico - Simbolos ----------------- */
semicolon: ';';
two_dots: ':';
comma: ',';
curly_open: '{' ;
curly_close: '}' ;
parenthesis_open: '(';
parenthesis_close: ')';
bracket_open: '[';
bracket_close: ']';
equal: '=';
plus: '+';
minus: '-';
greater_than: '>';
less_than: '<';
not_equal: '!' '=';
mult: '*';
div: '/';

/* ----------------- Lexico - Constantes ----------------- */
_letter : 'a'-'z' | 'A'-'Z' | '_' ; 
_digit : '0'-'9' ;

id : 'a'-'z' {'a'-'z'} { ('_' | 'A'-'Z') ('a'-'z' | 'A'-'Z' | '0'-'9') {'a'-'z' | 'A'-'Z' | '0'-'9'} } ;
myint : '0'-'9' {'0'-'9'} ;
myfloat : '0'-'9' {'0'-'9'} '.' '0'-'9' {'0'-'9'} ;
cte_string : '"' {_letter | ' ' | '!' | '?' }'"' ;

!whitespace : ' ' | '\t' | '\n' | '\r' ;

/* ----------------- Sintaxis ----------------- */
<< 
import "babyduck/semantic"
var functionDir = semantic.NewFunctionDirectory() 
>>

Start : Programa <<functionDir, nil>> ;

Programa : program id semicolon Program_vars FuncLoop main Body end ;

Program_vars : Vars
            | empty;

FuncLoop : Funcs FuncLoop
            | empty ;

Vars : var VarList two_dots Type semicolon << functionDir.RegisterGlobalVars($1.([]string), $3.(semantic.Type)) >> ;

VarList : id << functionDir.MakeVarList($0) >>
        | id comma VarList << functionDir.ConcatVarList($0, $2.([]string)) >> ;
        
Type : int_rw << semantic.Int, nil >>
     | float_rw << semantic.Float, nil >>
     | void << semantic.Void, nil >> ;

Register_Func : Type id << functionDir.RegisterFunction($1, $0.(semantic.Type), nil)>> ;

Funcs : Register_Func parenthesis_open ParamList parenthesis_close bracket_open Vars Body bracket_close semicolon
      | Register_Func parenthesis_open ParamList parenthesis_close bracket_open Body bracket_close semicolon 
      | Register_Func parenthesis_open parenthesis_close bracket_open Vars Body bracket_close semicolon 
      | Register_Func parenthesis_open parenthesis_close bracket_open Body bracket_close semicolon ;

ParamList : id two_dots Type << functionDir.RegisterParam($0, $2.(semantic.Type)) >>
          | id two_dots Type comma ParamList << functionDir.RegisterParam($0, $2.(semantic.Type)) >> ;

Body : curly_open Body_PR curly_close ;

Body_PR : Statement Body_PR
        | empty ;

Statement : Assign
          | Condition
          | Cycle
          | F_call
          | Print ;

Print : print parenthesis_open Expr Print_PR parenthesis_close semicolon
      | print parenthesis_open cte_string Print_PR parenthesis_close semicolon ;

Print_PR : comma Expr Print_PR
         | comma cte_string Print_PR
         | empty ;


Assign : id equal Expr semicolon << functionDir.ValidateAssign($0, $2.(semantic.Type)), nil >> ;

Cycle : while parenthesis_open Expr parenthesis_close do Body semicolon ;

Condition : if parenthesis_open Expr parenthesis_close Body semicolon
          | if parenthesis_open Expr parenthesis_close Body else Body semicolon ;

F_call : id parenthesis_open Expr F_call_PR parenthesis_close semicolon
       | id parenthesis_open parenthesis_close semicolon ;

F_call_PR : comma Expr F_call_PR
          | empty ;

Cte : myint << semantic.Int, nil >>
    | myfloat << semantic.Float, nil >> ;

Expr : Exp
     | Exp greater_than Exp << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >>
     | Exp less_than Exp << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >>
     | Exp not_equal Exp << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >> ;

Exp : Term
    | Term plus Exp << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >>
    | Term minus Exp << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >> ;

Term : Fact
     | Fact mult Term << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >>
     | Fact div Term << functionDir.BinaryExpression($0.(semantic.Type), $1, $2.(semantic.Type)) >> ;

Fact : parenthesis_open Expr parenthesis_close << $1.(semantic.Type), nil >>
     | Cte << $0.(semantic.Type), nil>>
     | id << functionDir.ResolveVarType($0) >>
     | plus id << functionDir.ResolveVarType($1) >>
     | minus id << functionDir.ResolveVarType($1) >>
     | plus Cte << $1.(semantic.Type), nil >>
     | minus Cte << $1.(semantic.Type), nil >> ;