/* ----------------- Lexico - Palabras reservadas ----------------- */
program : 'p' 'r' 'o' 'g' 'r' 'a' 'm';
main : 'm' 'a' 'i' 'n';
var: 'v' 'a' 'r';
end: 'e' 'n' 'd';
int_rw: 'i' 'n' 't';
float_rw: 'f' 'l' 'o' 'a' 't';
void: 'v' 'o' 'i' 'd';
while: 'w' 'h' 'i' 'l' 'e';
do: 'd' 'o';
print: 'p' 'r' 'i' 'n' 't';
if: 'i' 'f';
else: 'e' 'l' 's' 'e';

/* ----------------- Lexico - Simbolos ----------------- */
semicolon: ';';
two_dots: ':';
comma: ',';
curly_open: '{';
curly_close: '}';
parenthesis_open: '(';
parenthesis_close: ')';
bracket_open: '[';
bracket_close: ']';
equal: '=';
plus: '+';
minus: '-';
greater_than: '>';
less_than: '<';
not_equal: '!' '=';
mult: '*';
div: '/';

/* ----------------- Lexico - Constantes ----------------- */
id : 'a'-'z' {'a'-'z'} { ('_' | 'A'-'Z') ('a'-'z' | 'A'-'Z' | '0'-'9') {'a'-'z' | 'A'-'Z' | '0'-'9'} } ;
myint : '0'-'9' {'0'-'9'} ;
myfloat : '0'-'9' {'0'-'9'} '.' '0'-'9' {'0'-'9'} ;
string : '"' {'a'-'z' | 'A'-'Z'} '"' ;

!whitespace : ' ' | '\t' | '\n' | '\r' ;

/* ----------------- Sintaxis ----------------- */
<< import "babyduck/semantic" >>

Start : Programa ;

Program_Create : id << semantic.CreateFunction($0, true) >>;

Programa : program Program_Create semicolon Vars Programa_PR main Body end
| program Program_Create semicolon Programa_PR main Body end;

Programa_PR : Funcs Programa_PR
| empty;

Enqueue_Vars : id << semantic.AddVarToQueue($0) >> ;

Declare_Vars : Type << semantic.AddVarsToTable($0.(string)) >> ;

Vars : var Enqueue_Vars Vars_PR two_dots Declare_Vars semicolon Vars_PR_PR ;

Vars_PR : comma Enqueue_Vars Vars_PR
| empty ;

Vars_PR_PR : Enqueue_Vars Vars_PR two_dots Declare_Vars semicolon Vars_PR_PR
| empty ;

Type : int_rw << semantic.SetCurrentType("int") >> | float_rw << semantic.SetCurrentType("float") >> ;

Body : curly_open Body_PR curly_close;

Body_PR : Statement Body_PR
| empty ;

Statement : Assign
| Condition
| Cycle
| F_call
| Print;

Print : print parenthesis_open Expr Print_PR parenthesis_close semicolon
| print parenthesis_open string Print_PR parenthesis_close semicolon;

Print_PR : comma Expr Print_PR
| comma string Print_PR
| empty ;

Assign : id equal Expr semicolon << semantic.AssignVarValue($0, $2.(string)) >>;

Cycle : while parenthesis_open Expr parenthesis_close do Body semicolon;

Condition : if parenthesis_open Expr parenthesis_close Body semicolon
| if parenthesis_open Expr parenthesis_close Body else Body semicolon;

F_call : id parenthesis_open parenthesis_close semicolon
| id parenthesis_open Expr F_call_PR parenthesis_close semicolon;

F_call_PR : comma Expr F_call_PR
| empty ;

Cte : myint << "int" >>
| myfloat << "float" >>;

Expr : Exp
| Exp greater_than Exp << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>
| Exp less_than Exp << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>
| Exp not_equal Exp << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>;

Exp : Term
| Term plus Exp << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>
| Term minus Exp << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>;

Term : Fact
| Fact mult Term << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>
| Fact div Term << semantic.BinaryExpression($0.(string), $1, $2.(string)) >>;

Fact : parenthesis_open Expr parenthesis_close << $1.(string) >>
| Cte
| id << semantic.GetVarValue($0) >>
| plus id << semantic.GetVarValue($1) >>
| minus id << semantic.GetVarValue($1) >>
| plus Cte << $1.(string) >>
| minus Cte << $1.(string) >>;

Func_Create : id << semantic.CreateFunction($0, false) >>;

Funcs : void Func_Create parenthesis_open parenthesis_close bracket_open Body bracket_close semicolon
| void Func_Create parenthesis_open parenthesis_close bracket_open Vars Body bracket_close semicolon;